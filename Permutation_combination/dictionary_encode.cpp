/*
问题描述：

在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表A由26个小写字母组成。该字母表产生的升序字符串中字母从左到右出现的次序与字母在字母表中出现
的次序相同，且每个字符最多出现1次。例如，a,b,ab,bc,xyz等字符串都是升序字符串。现在对字母表中产生的所有长度不超过6的升序字符串，计算它在字典中的编码。
a b c … ab ac
1 2 3 … 27 28
 
样例输入：
 2
 a
 b
样例输出：
 1
 2  

*/

/*
解法1：
由题意可知字符串对应的序号就是其从小到大排列组合的位置，因为字符串是升序排列，所以以第i个字母开头长度为k的字符串的数量f（i，k）=sumj=i+1:26（f（j,k-1）
）;因此要想求得字符串的位置，需要求出其前面有多少字符串，首先长度小于给出字符串长度k的所有字符串，第二，所有开头字母小于给出字符串开头字母并且长度为k的
字符串数量，最后还有开头字母相等长度相等但是后面字母小于已给字符串字母的所有字符串。
*/

#include<stdio.h>   
#include<string.h>  
  
int f(int i,int k){  
    int j;  
    int sum=0;  
    if(k==1){  
        return 1;  
    }else{  
        for(j=i+1;j<=26;j++){  
            sum+=f(j,k-1);  
        }   
    }  
    return sum;  
}//第i个字母开头长度为k的数量   
int ca(char a[]){  
    int i,j,count,n,length;  
    int sum=0;  
    int k=strlen(a);  
    for(i=1;i<k;i++){  
        for(int j=1;j<=26;j++){  
            sum+=f(j,i);  
        }      
    } // 该字符串的位置就是小于k长度的数量，  
    int h=a[0]-'a'+1;  
    for(int i=1;i<h;i++){  
        sum+=f(i,k);   
    }//加上小于开头字母的长度为k的数量，  
      
    count = h;  
    for(i=1;i<k;i++){  
        n= a[i]-'a'+1;  
        length=k-i;  
        for(j=count+1;j<n;j++){  
            sum+=f(j,length);   
        }   
        count=n;      
    }//再加上字符串中字母与其后面字母之间字母开头的k-i长度字符串的数量   
    return sum+1;  
}  
int main()  
{  
    int n;  
    char a[30];  
    long long x;  
    scanf("%d",&n);  
    getchar();  
    while(n--){  
        x=0;  
        gets(a);  
        x=ca(a);  
        printf("%d\n",x);  
    }  
    return 0;  
}  


/*
解法2：
使用排列组合思想，将每个字符串长度为k即为使用字母将这k个空位进行填充，一共有26-j个字母可供选择，所以可能种类数量为从26-j个字母中随便选择k个。函数C
就是求排列组合数量。
因此
①将长度小于已给字符串长度的所有字符串数量算出。也就是长度从1到len-1，可选字母为26个字母都可以。
②将长度等于已给字符串长度len的字符串数量，而此时也要分解：首先以小于开头字母的字母开头的长度为len的所有字符串都满足条件，所以实际字符串开头字母从a
开始小于已给字符串开头字母，实际求取字符串长度为len；其次，从第二位开始，实际求取字符串开头字母应该大于第一位字母小于后一位字母，实际长度为len-1；
依次类推知道实际字符串长度为1。
最后sum再加上1（本身位置）即为最终结果。
*/

#include <stdio.h>  
#include<string.h>  
  
int C(int x,int y)  
{  
    int i=y;  
    int temp=0;  
    int a,b;  
    a=b=1;  
    while(i && x)  
    {  
        a*=x;  
        i--;  
        x--;  
    }  
    while(y)  
    {  
        b*=y;  
        y--;  
    }  
    temp=a/b;  
    return temp;  
}  
//C(x,y)；是一个上层为y，下层为x的排列组合，x是指填充字符串的字母可能数量,y是指字符串的长度。   
int main()  
{  
    int n,i,j,start,sum,len;  
    char a[26];  
    while(~scanf("%d",&n))  
    {  
        getchar();  
        while(n--){  
            sum=0;  
            start=1;  
            gets(a);  
            len=strlen(a);  
            for(i=1;i<len;i++)  
                sum+=C(26,i);  
            //传递参数中i为字符串长度，此时每个字符串的可选择字母为26个字母都可以。 26不做变化   
            //长度小于已知字符串长度的所有数量。  
            for(j=len;j>0;j--){  
                //控制实际求取字符串的长度   
                for(i=start;i<a[len-j]-'a'+1;i++){  
                    //控制实际求取字符串的开头字母   
                    sum+=C(26-i,j-1);  
                // 第一个参数：因为字符串为递增，  
                    //所以字符串开头之后的位置填充（字母种类）为（总字母数量26）减去（开头字母之前的字母数量）   
                //第二个参数：因为开头字母已经人为确定，  
                    //所以此时实际应求数量的字符串长度为i-1（即应该填充的字母数量）    
                }  
                start=a[len-j]-'a'+2;  
                //因为实际字符数量求取过程已经完成，所以要进行下一位求取；  
            //因字符串为递增，所以可能情况为之前字母加1；而且要小于之后字母     
            }  
            printf("%d\n",sum+1);  
        }  
    }  
    return 0;  
}  
